Отвечаю как техлид — **решения фиксирую**, чтобы дальше не было “плавающих” трактовок. И да: **делай CodingKeys**, следуем spec, а где я упростил — это была моя ошибка/упрощение, исправляю сейчас.

---

## 1) Связь AnimiApp ↔ TVECore

**Делаем так:**

* `AnimiApp` = обычный `.xcodeproj`
* `TVECore` = **local Swift Package** (`Package.swift`) в корне репо
* Подключение в Xcode: *Add Packages → Add Local…* и выбираем папку `TVECore`

**Workspace НЕ нужен**. Он появится автоматически, если Xcode захочет — но в репе мы не обязаны его хранить.
Цель: чтобы `swift test` и CI могли жить отдельно, а app был только демо-хостом.

---

## 2) Naming / маппинг полей JSON ↔ Swift

Да, **делай `CodingKeys` строго по spec**.

Правило: **Swift-имена нормальные (`id`, `rect.width`)**, но декодинг — из JSON-ключей spec.

Конкретно:

* `MediaBlock.id` ⇐ `blockId`
* `Variant.id` ⇐ `variantId`
* `Rect.w/h` НЕ делаем. Делаем **`width/height`** в Swift, чтобы не плодить “внутренний диалект”.

✅ Итог: `Rect { x, y, width, height }`

---

## 3) ContainerClip — фиксируем по spec

Ты прав: в spec значения другие и поле стоит **на уровне MediaBlock**.

**Решение:**

* В PR1 делаем **как в spec**:

  * `MediaBlock.containerClip: ContainerClip`
  * `enum ContainerClip { slotRect, slotRectAfterSettle, none }`

В Variant **containerClip не держим** (убираем из ТЗ PR1).
Если позже понадобится override на variant — это будет **новое поле spec vNext**, не в Part 1.

---

## 4) Background — делаем по spec

Тоже верно: по spec это не строка, а объект.

**Решение:**

* `Canvas.background: Background?`
* `Background { type: String, color: String? }`

Не упрощаем. PR1 — это фундамент, лучше сразу правильно.

---

## 5) Test Assets — откуда брать JSON

Файлы **уже есть** — используем **реальные** из твоего test package:

* `scene.json` 
* `anim-1.json`…`anim-4.json`

Ничего “сам по спецификации” не генерируй — это опасно (можно не попасть в реальные edge cases).

---

## 6) Минимальная iOS версия (deployment target)

Фиксируем: **iOS 16+**.

Почему:

* Metal/MTKView стабильно
* современные concurrency/Swift toolchain проще
* нам не нужно тратить время на backwards-compat для Part 1

Если тебе критично iOS 15 — поднимешь флаг, но по умолчанию ставим 16.

---

# Обновлённые правки к моему ТЗ (чтобы ты не гадал)

В PR1:

* Models **строго по `scene_json_spec_v_0.md`** (ключи spec через CodingKeys)
* `Rect` = `x, y, width, height`
* `containerClip` на `MediaBlock` и enum из spec
* `background` объектом, не строкой
* Loader API и тесты — как я писал, но с учётом этих моделей

---

## Мини-чеклист для тебя перед стартом

1. Сделал SPM `TVECore` + подключил в app
2. Положил test package в `TestAssets/ScenePackages/example_4blocks/`
3. Loader грузит **реальный** `scene.json`, резолвит `animRef` файлы
4. Unit tests: success + missing scene + missing anim

---

Если ок — начинай PR0 → PR1 одним PR или двумя (лучше **двумя**, чтобы инфраструктура не мешала ревью лоадера).

---

Ниже — точное ТЗ для разработчика на **PR0** и **PR1** (старт с нуля). Оно написано так, чтобы после PR1 мы уже могли **открыть ваш test ScenePackage** (`scene.json` + `anim-*.json`) и получить в коде готовый `ScenePackage` объект + список путей к anim-файлам/ассетам. Основа — ваш план Release Part 1  и тестовый пакет .

---

# PR0 — Repo + iOS shell + инфраструктура (без логики парсинга)

## Цель PR0

Создать чистый репозиторий и минимальное iOS-приложение/раннер, куда дальше “встанет” движок. Никакого рендера и компиляции ещё нет — только каркас, сборка, линт, тесты, CI.

## Deliverables

### 0.1 Структура проекта (обязательная)

* `AnimiApp/` — iOS app target (Swift, UIKit + MTKView заглушка)
* `TVECore/` — Swift Package (основной код движка)

  * `Sources/TVECore/`
  * `Tests/TVECoreTests/`
* `Tools/` (опционально) — скрипты, если нужны
* `TestAssets/ScenePackages/<packageName>/...` — папка с тестовыми пакетами (см. ниже)

### 0.2 CI (обязательное)

* GitHub Actions: сборка + тесты на macOS (latest).
* Команда: `xcodebuild test` (или `swift test` если тесты в SPM).
* Артефакты не нужны.

### 0.3 Код-стайл (обязательное)

* SwiftFormat или SwiftLint (выбрать одно).
* Настроить так, чтобы:

  * PR не “захлёбывался” тысячей варнингов,
  * правила базовые: trailing whitespace, line length (разумно), force unwrap запрещать в core.

### 0.4 iOS shell (обязательное)

* Экран `PlayerViewController`:

  * сверху кнопка “Load Test Package”
  * текстовый лог (UITextView) для вывода событий
  * `MTKView` можно добавить сразу (пока просто clearColor), чтобы в следующих PR без боли подключить рендер.

### 0.5 Test Assets (обязательное)

Добавить ваш реальный пакет в репозиторий:

* `TestAssets/ScenePackages/example_4blocks/scene.json` 
* `TestAssets/ScenePackages/example_4blocks/anim-1.json`…`anim-4.json`
  (папку `images/` добавить если появится позже)

## Definition of Done PR0

* Репозиторий собирается в Xcode.
* CI зелёный.
* Есть app shell с экраном и логом.
* В репе лежит test package (json файлы).

---

# PR1 — ScenePackageLoader + модели Scene.json (без “валидации Spec”)

## Цель PR1

Реализовать **загрузку ScenePackage** из папки (bundle) и парсинг `scene.json` в строго типизированные модели. Также — собрать пути ко всем referenced `animRef` файлам (но **не парсить Lottie**).

Это соответствует шагу 1 плана: “Load ScenePackage”. 

## Scope (строго)

✅ Входит:

* Models для `scene.json` (минимально достаточные поля)
* Loader, который:

  * находит `scene.json`
  * декодит в `Scene`
  * резолвит `animRef` → полный путь к `anim-*.json`
  * возвращает `ScenePackage` (scene + resources)
* Ошибки загрузки/парсинга (чёткие enum)
* Интеграция в app shell: кнопка “Load Test Package” реально грузит пакет и пишет summary в лог

❌ Не входит:

* Валидация Spec v0.1 (это PR2)
* Парсинг anim json (это PR3)
* Рендер/Metal (позже)

---

## 1) API контракты (обязательные)

### 1.1 Типы данных

В `TVECore` создать:

```swift
public struct ScenePackage {
    public let rootURL: URL
    public let scene: Scene
    public let animFilesByRef: [String: URL]   // animRef -> file URL
    public let imagesRootURL: URL?             // rootURL/images если есть
}
```

```swift
public enum ScenePackageLoadError: Error, Equatable {
    case sceneJSONNotFound
    case sceneJSONReadFailed(String)
    case sceneJSONDecodeFailed(String)
    case animFileNotFound(animRef: String)
    case invalidPackageStructure(String)
}
```

### 1.2 Loader

```swift
public final class ScenePackageLoader {
    public init(fileManager: FileManager = .default)

    public func load(from rootURL: URL) throws -> ScenePackage
}
```

Поведение:

* `rootURL` — папка ScenePackage.
* `scene.json` MUST существовать в корне.
* `images/` — опционально.
* Для каждого `mediaBlocks[].variants[].animRef`:

  * ожидаем файл в корне пакета (например `anim-1.json`)
  * если отсутствует → `animFileNotFound`.

### 1.3 Логика резолва animRef (обязательная)

* `animRef` в `scene.json` может быть:

  * `anim-1.json` (с расширением)
  * `anim-1` (без расширения)
* Loader должен поддержать оба варианта:

  * если расширение отсутствует → добавить `.json`.

---

## 2) Models для scene.json (обязательные поля)

Опираться на ваш `scene.json`. 

Минимальный набор:

```swift
public struct Scene: Decodable {
    public let schemaVersion: String
    public let canvas: Canvas
    public let mediaBlocks: [MediaBlock]
}

public struct Canvas: Decodable {
    public let width: Int
    public let height: Int
    public let fps: Int
    public let durationFrames: Int
    public let backgroundColor: String?
}
```

`MediaBlock`:

```swift
public struct MediaBlock: Decodable {
    public let id: String
    public let bindingKey: String?          // в PR2 станет MUST
    public let rect: Rect                  // позиция блока на канвасе
    public let variants: [Variant]
    public let input: MediaInput
    public let timing: Timing?
    public let zIndex: Int?
}
```

Геометрия:

```swift
public struct Rect: Decodable {
    public let x: Double
    public let y: Double
    public let w: Double
    public let h: Double
}
```

Variant:

```swift
public struct Variant: Decodable {
    public let id: String
    public let animRef: String
    public let containerClip: ContainerClip?
    public let name: String?
}
```

Input:

```swift
public struct MediaInput: Decodable {
    public let allowedMedia: [String]      // "photo"/"video"/"color" (PR2 проверит)
    public let rect: Rect                  // одинаковый для всех variants (PR2 проверит)
    public let defaultContent: DefaultContent?
}
```

Timing:

```swift
public struct Timing: Decodable {
    public let startFrame: Int
    public let endFrame: Int
}
```

Clip:

```swift
public enum ContainerClip: String, Decodable {
    case rect
    case none
}
```

DefaultContent (минимально):

```swift
public struct DefaultContent: Decodable {
    public let type: String   // "color"...
    public let value: String? // "#RRGGBB"
}
```

### Важно по декодингу (обязательное)

* Использовать `JSONDecoder` с `keyDecodingStrategy = .useDefaultKeys` (у вас snake_case не видно).
* Все неизвестные поля должны **игнорироваться**, чтобы scene.json мог расширяться без поломок (в Swift Decodable это по умолчанию ок).

---

## 3) Интеграция в iOS app (обязательное)

В `PlayerViewController`:

* По кнопке “Load Test Package”:

  * берём `Bundle.main.url(forResource: "scene", withExtension: "json", subdirectory: "TestAssets/ScenePackages/example_4blocks")`
  * `rootURL` = parent directory
  * вызываем `ScenePackageLoader.load(from:)`
  * выводим в лог:

    * canvas (w/h/fps/durationFrames)
    * количество `mediaBlocks`
    * для каждого блока: id, rect, variants count
    * список `animFilesByRef` (key -> lastPathComponent)

---

## 4) Unit Tests (обязательные)

`TVECoreTests`:

### 4.1 `testLoadExamplePackage_success()`

* Грузим `example_4blocks`.
* Проверяем:

  * `scene.canvas.fps == 30`
  * `scene.mediaBlocks.count == 4`
  * `animFilesByRef.count == 4`
  * каждый animRef резолвится в существующий файл URL.

### 4.2 `testLoad_missingSceneJson_fails()`

* создаём временную директорию без `scene.json`
* ожидаем `.sceneJSONNotFound`

### 4.3 `testLoad_missingAnimRef_fails()`

* копируем пакет во временную папку, удаляем один `anim-*.json`
* ожидаем `.animFileNotFound(animRef: ...)`

(В PR1 тесты должны быть быстрые и без iOS UI.)

---

## 5) Acceptance checklist для PR1 (что я буду проверять)

* Loader не делает “магии”: только загрузка/парсинг/резолв ссылок.
* Ошибки читаемые, без `fatalError`.
* Нет force unwrap в core.
* Unit tests зелёные и реально читают ваши json.
* App экран показывает понятный лог по загруженной сцене.

---

## Что разработчик должен приложить к PR0/PR1

* Скриншот/видео (можно 10 сек) работы кнопки “Load Test Package” и лога.
* Короткое описание: “что сделано / как запустить / где лежит test package”.

---

Если хочешь, следующим сообщением я выдам **точное ТЗ на PR2** (SceneValidator v0.1) уже на базе `scene_json_spec_v_0.md`, включая список MUST-ошибок и WARN-ов и их коды. 
