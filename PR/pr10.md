Отлично — значит **pipeline “Lottie → AnimIR → RenderCommands → Metal”** уже живой (с masks + mattes) и можно двигаться к тому, ради чего всё делалось: **сцена из `scene.json` с N медиа-блоками**.

## Следующий PR = **PR10: ScenePlayer (scene.json → N blocks) + playback/scrub/loop на девайсе**

Цель PR10: в приложении ты видишь **полный шаблон-сцену** (все 4 блока одновременно, как в CapCut/Unfold), а не одну anim.

---

# PR10 — “железобетонное” ТЗ

## 1) Что должно заработать (Definition of Done)

1. Загружаем **ScenePackage** (`scene.json` + `anim-*.json` + `images/`)
2. Валидируем `scene.json` и каждый `anim-*.json` (у вас уже есть валидаторы)
3. Компилируем **каждый variant.animRef → AnimIR**
4. На каждый кадр `frameIndex`:

   * строим RenderCommands **для всех медиа-блоков сцены**
   * применяем **layout блока на canvas** (block.rect + input.rect mapping)
   * рисуем всё в одном MTKView через ваш MetalRenderer (уже умеет masks+mattes)
5. UI: **Play/Pause + Scrub slider + FPS label** (как сейчас) — но управляет **scene frame**, а не одной anim.

---

## 2) Архитектура PR10 (минимальная, без “лишней инженерии”)

### 2.1 Новый модуль в TVECore

`Sources/TVECore/ScenePlayer/`

Файлы:

* `ScenePlayer.swift` — основной класс
* `ScenePlayerTypes.swift` — структуры runtime: `SceneRuntime`, `BlockRuntime`, `VariantRuntime`
* `SceneRenderPlan.swift` — сборка “какие команды рисовать в кадре”
* `ScenePlayerError.swift`

### 2.2 Главные структуры (контракт)

**SceneRuntime**

* `scene: Scene` (decoded)
* `canvas: Canvas`
* `blocks: [BlockRuntime]`
* `durationFrames: Int` (из canvas.durationFrames)
* `fps: Int`

**BlockRuntime**

* `blockId`
* `rectCanvas: RectD` (где блок лежит в canvas)
* `inputRect: RectD` (из scene.json)
* `selectedVariantId` (пока default)
* `variants: [VariantRuntime]`

**VariantRuntime**

* `variantId`
* `animRef`
* `animIR: AnimIR`
* `assetIndex: AssetIndexIR` (уже внутри animIR.assets)
* `bindingKey: String` (например `"media"`)

---

## 3) Ключевая логика PR10

### 3.1 “Scene frameIndex” → “Anim frameIndex”

Правило: **пока 1:1** (без сложных тайминг-политик):

* `sceneFrameIndex` в [0 .. scene.durationFrames-1]
* для каждого блока: вычислить `localFrameIndex`:

  * если есть `timing.startFrame` / `timing.range` в scene.json — применить
  * если нет — `localFrame = sceneFrameIndex`
* clamp в `[0 .. animIR.op-1]`

(Loop policies `loopRange` / `ifAnimationShorter` — оставить на PR11+, если они ещё “не канон”.)

### 3.2 Layout: как разместить anim внутри block.rect

Нужно сделать **одно преобразование**, которое добавляется перед командами конкретного блока:

`M_block = animToViewportContain(animSize: animIR.meta.size, viewportSize: block.rectCanvas.size) + translate(block.rectCanvas.origin)`

То есть:

1. содержимое anim приводим к размеру блока (contain+center) — используем ваш `GeometryMapping.animToInputContain` или аналог
2. затем переносим в позицию блока на canvas

В RenderCommands это делается так:

```
beginGroup("block:\(blockId)")
  pushTransform(M_block)
    ...commands from animIR.renderCommands(frameIndex: localFrame)...
  popTransform
endGroup
```

Важно: **не пытаться переписывать команды** — просто оборачиваем transform’ом сверху.

### 3.3 Clip по block.rectCanvas (обязательно)

Чтобы блок не “вылезал” за пределы:

```
pushClipRect(block.rectCanvas)
  pushTransform(M_block)
    ...
  popTransform
popClipRect
```

(clip должен работать с masks/mattes — у вас это уже закрыто в PR8.)

---

## 4) TextureProvider для сцены

Используем **один** `ScenePackageTextureProvider` на весь scene package:

* `imagesRootURL` общий
* но `assetIndex` у каждого anim свой

Как сделать без усложнения:

* создать `MultiAssetTextureProvider` (wrapper), который:

  * хранит `[animRef: ScenePackageTextureProvider]`
  * на `texture(for assetId)` ищет в providers по очереди **или** по префиксу ключа

Лучше и проще в PR10:

* не усложнять provider API
* вместо этого перед рендером блока устанавливать `provider = providersByAnimRef[animRef]` и рисовать блок одним вызовом `renderer.draw(...)` **в тот же commandBuffer/encoder** нельзя (renderer сейчас сам создаёт encoders), поэтому:

✅ Правильный минимальный подход:

* **собрать одну общую командную ленту** на кадр для всех блоков
* и использовать **один provider**, который умеет доставать textures по assetId независимо от animRef

Поэтому PR10 MUST добавить:

### `SceneTextureProvider`

* хранит `providers: [ScenePackageTextureProvider]`
* `texture(for assetId)`:

  * пробует по providers, пока не найдёт texture (кэширует успех/неуспех)
* логгер один общий

Это дешево, но работает.

---

## 5) AnimiApp — новый режим в PlayerViewController

В UI добавить переключатель (можно временно hidden):

* “Play single anim” / “Play scene”

В “scene mode”:

* load package → создаётся `ScenePlayer`
* slider управляет `sceneFrameIndex`
* draw вызывает `scenePlayer.renderCommands(sceneFrameIndex)` и отдаёт в `MetalRenderer.draw(...)`

---

## 6) Тесты PR10 (минимум)

Новые тесты в TVECoreTests:

1. `ScenePlayerLoadsExample4Blocks_compilesAllAnimRefs()`

* из test package `example_4blocks` загрузить `scene.json`
* убедиться, что нашлись `anim-1..4`
* создан runtime с 4 блоками

2. `ScenePlayer_frame0_generatesCommandsForVisibleBlocks()`

* frame=0 → у тех, у кого ip позже, commands drawImage=0
* у видимых — >0

3. `ScenePlayer_appliesBlockTransformAndClip()`

* для любого блока проверить, что в общей ленте есть:

  * `pushClipRect(blockRect)`
  * `pushTransform(M_block)` не identity

4. `ScenePlayer_determinism_sameFrameSameCommandsStructure()`

---

# Почему PR10 — самый правильный следующий шаг

Потому что дальше идут либо:

* PR11 “golden-image harness” (авто-регрессия пикселей) — но он бессмысленен, пока не рендерим сцену целиком
* либо “медиа подстановки/контент” — но без ScenePlayer это некуда вставлять

PR10 делает продукт “ощутимым”: **реальный шаблон на девайсе**.

---

Если хочешь, могу сразу после этого накидать **PR11** (golden frames + сравнение кадров + допуски) — это будет следующий логичный PR после PR10.
