Да, понимаю глобальную идею 1-в-1:

* **Lottie JSON (bodymovin) читаем и компилим один раз** при загрузке сцены/шаблона → получаем **AnimIR/RenderGraph + GPU-ресурсы**.
* Дальше (preview/scrub/export) работаем **только по frameIndex**, максимально детерминированно.
* В финальном рендере **CPU не должен “рисовать”** (никакой CoreGraphics-rasterize на каждый кадр); CPU может только **вычислять/выбирать** параметры и отправлять команды, но **вся отрисовка масок/маттов — на Metal**.

---

## 1) Текущий статус проекта по “animated matte mask” из anim-3.json

**Коротко: сейчас анимированная форма matte-mask НЕ реализована.**

Почему это факт по коду из `project_snapshot.zip`:

### A) Декодинг path-keyframes в Lottie сломан под shape paths

Файл: `TVECore/Sources/TVECore/Lottie/LottieTransform.swift`

* `LottieKeyframe.startValue` имеет тип **`[Double]?`**, а для path keyframes в JSON приходит **PathData** (`{"s":[{"v":...,"i":...,"o":...,"c":true}]}`), не массив чисел.
* Значит keyframes для `ks` у shape path сейчас корректно не поднимаются как PathData.

### B) AnimIRPath/ShapePathExtractor берут только static path

Файл: `TVECore/Sources/TVECore/AnimIR/AnimIRPath.swift`

* `ShapePathExtractor.extractPath(...)` возвращает `BezierPath(from: pathShape.vertices)` и **ожидает static `.path`**.
* `BezierPath.init(from animatedValue:)` **возвращает nil**, если там keyframes (сейчас это так и написано).
* В `AnimIR.renderCommands` маски берутся как `mask.path.staticPath` → то есть **форма не меняется по кадрам**.

### C) Финальный рендер масок/shape сейчас делается CPU-rasterize → это против твоего требования

Файлы:

* `TVECore/Sources/TVECore/MetalRenderer/MaskRasterizer.swift` (CoreGraphics rasterize)
* `TVECore/Sources/TVECore/MetalRenderer/MaskCache.swift` (делает r8 текстуру через CPU)
* `TVECore/Sources/TVECore/MetalRenderer/ShapeCache.swift` (то же самое для shape fill)

То есть даже “статические” маски сейчас рисуются через CPU bitmap.

---

## 2) Что говорится про анимированные маски в “Release Part 1 plan”

Файл: `release_part_1_detailed_implementation_plan_tech_lead.md`

* В PR8/PR9 описана поддержка **masks + track mattes**, но **про animated mask paths (pt.a==1 / ks.a==1)** там **нет цели**.
* Более того, в PR8 прямо сказано, что для Part 1 **допустимо CPU rasterize** (как временно допустимый компромисс).
  Ты сейчас требуешь наоборот: **релизное решение и архитектурно правильно, без CPU rasterize в финале**.

---

# 3) Конкретный план для программиста (без “вопросов”)

Ниже план так, чтобы:

* анимированные mask paths заработали и в masksProperties, и в matte source shapes,
* код не дублировался (единый Path pipeline),
* CPU-rasterize в финальном рендере исчез полностью,
* тесты фиксируют именно “форма меняется по кадрам” + визуальный эффект в anim-3.

---

## PR-A — Починить Lottie path keyframes (декодинг) без костылей

**Цель:** `ks` для shape path (`ty="sh"`) и mask path (`pt`) декодится как PathData и доступен как keyframes.

### Изменения

1. `TVECore/Sources/TVECore/Lottie/LottieTransform.swift`

* Заменить `LottieKeyframe.startValue: [Double]?` и `endValue: [Double]?`
  на **тип, который умеет и numbers/arrays, и path**. Самый прямой вариант:

  * `public let startValue: LottieValueData?`
  * `public let endValue: LottieValueData?`
* В `init(from:)` декодить `s`/`e` через `LottieValueData` (он уже умеет `.path(LottiePathData)`).

2. `TVECore/Sources/TVECore/AnimIR/AnimIRTrack.swift`

* Обновить `extractVec2DKeyframes` / `extractDoubleKeyframes`:

  * вместо `kf.startValue as [Double]` брать `kf.startValue` и распаковывать `.array([Double])`.

### DoD (Definition of Done)

* `Bundle.module/Resources/example_4blocks/anim-3.json` декодится без skip.
* Добавить юнит-тест на декодинг shape path keyframes:

  * файл: `TVECore/Tests/TVECoreTests/ShapeItemDecodeTests.swift`
  * проверить: `ks.a==1`, keyframes count == 2, времена 60 и 90, в `startValue` лежит `.path(...)`.

---

## PR-B — AnimIR: настоящая анимация Path (mask + shape matte), интерполяция

**Цель:** в IR хранится **AnimPath**, умеющий `sample(frame)`.

### Изменения

1. `TVECore/Sources/TVECore/AnimIR/AnimIRTypes.swift`

* `ShapeGroup.path: BezierPath?` → заменить на `AnimPath?` (или `AnimPath` + флаг empty).

2. `TVECore/Sources/TVECore/AnimIR/AnimIRPath.swift`

* Переписать `AnimPath` так, чтобы он реально содержал keyframes PathData:

  * Ввести `struct PathData` (vertices/inTangents/outTangents/closed) на `Vec2D`.
  * `AnimPath.track: AnimTrack<PathData>`
  * Реализовать `sample(frame:) -> PathData` и `sampleBezier(frame:) -> BezierPath`
  * Интерполяция: vertex-by-vertex lerp **только если совпадает count** (иначе — UnsupportedFeature/validation error).
* `Mask(from:)` должен собирать `AnimPath` из `mask.path` (LottieAnimatedValue), включая keyframes `.path(LottiePathData)`.

3. `TVECore/Sources/TVECore/AnimIR/AnimIRCompiler.swift`

* `compileContent` для `.shapeMatte`:

  * `ShapePathExtractor.extractPath` заменить на `extractAnimPath`.
* `ShapePathExtractor` (в этом же файле `AnimIRPath.swift`) должен уметь:

  * найти `sh.ks` как `LottieAnimatedValue` и вернуть `AnimPath` (static или keyframed).

4. `TVECore/Sources/TVECore/AnimIR/AnimIR.swift`

* Сейчас маски берут `mask.path.staticPath`. Нужно:

  * либо временно строить BezierPath на CPU через `mask.path.sampleBezier(frame:)` (для команд),
  * либо (лучше, под следующий PR) перейти на `pathId`/resource-ref (см. PR-C).

### Тесты (обязательные)

1. Новый тест: `TVECore/Tests/TVECoreTests/AnimatedPathSamplingTests.swift`

* Загружаем `anim-3.json` → компилим → находим matte source shape path (`img_1.3_mask`).
* Проверяем, что AABB/ширина пути на frame 60 **меньше**, чем на frame 90 (т.е. форма реально изменилась).

2. Расширить `AnimValidatorTests.swift` / `AnimValidator.swift`

* Сейчас валидатор запрещает animated mask path. Нужно:

  * разрешить,
  * но добавить правило: “для интерполяции vertex count MUST match между keyframes” (иначе error `UnsupportedFeature(animated_path_mismatch_vertices)`).

---

## PR-C — Релизный GPU-pipeline для masks + shapes (никакого CPU rasterize)

**Цель:** MaskRasterizer/MaskCache/ShapeCache больше не участвуют в кадре. Маски/шейпы рисуются в Metal через общий Path renderer.

### Архитектура (единая, без дубликатов)

* Ввести один модуль: **PathMesh** (компиляция один раз) + **PathRenderer** (GPU draw).
* Одинаково используется для:

  * layer masks (`masksProperties`)
  * matte source shapes (`ty=4`)

### Конкретные правки по файлам

1. Удалить/обездвижить CPU raster:

* `TVECore/Sources/TVECore/MetalRenderer/MaskRasterizer.swift` — больше не используется в прод-пайплайне.
* `MaskCache.swift`, `ShapeCache.swift` — либо удалить, либо оставить только под debug, но **MetalRenderer+Execute** должен перестать их вызывать.

2. `TVECore/Sources/TVECore/RenderGraph/RenderCommand.swift`

* Заменить payload `BezierPath` на **ссылку на ресурс**:

  * `.beginMaskAdd(pathId: Int, opacity: Double)`
  * `.drawShape(pathId: Int, fillColor: [Double]?, fillOpacity: Double, layerOpacity: Double)`
* Это ключевой шаг, чтобы:

  * не таскать большие path структуры в командах,
  * не “готовить” path на CPU на каждый кадр,
  * иметь 1 GPU-ресурс на путь.

3. `TVECore/Sources/TVECore/AnimIR/AnimIR.swift`

* `AnimIR` должен иметь `pathRegistry` (массив/словарь PathResource).
* Для каждой Mask/ShapeGroup при компиляции регистрировать `pathId`.
* `renderCommands(frameIndex:)` эмитит команды с `pathId`, без BezierPath.

4. Новый тип ресурсов в AnimIR (компиляция один раз)
   Файл: удобно рядом с `AnimIRPath.swift` или новым `AnimIRPathResources.swift`:

* `struct PathResource`:

  * `id`
  * `vertexCount`, `indexCount`
  * `keyframes: [ (time, vertexOffset) ]`
  * `positions: [SIMD2<Float>]` **для всех keyframes подряд**
  * `indices: [UInt32]` (триангуляция единожды)
* Триангуляция: earcut/ear-clipping на CPU **при компиляции**.
* Для anim-3 vertexCount одинаковый (4) — отличный baseline.

5. `TVECore/Sources/TVECore/MetalRenderer/MetalRendererResources.swift`

* Добавить новый pipeline:

  * `path_fill_vertex` / `path_fill_fragment` (рисует заливку в color target; для matte source)
  * `path_stencil_vertex` / `path_stencil_fragment` (пишет в stencil; для masks) — fragment может быть `void`, без texture sampling.
* Важно: это **не** текстурный maskTex, а **прямая геометрия в stencil**.

6. `TVECore/Sources/TVECore/MetalRenderer/MetalRenderer+Execute.swift`

* `renderMaskScope`:

  * убрать “Step 2: maskTex from maskCache”
  * сделать:

    * Pass A: render inner commands → `contentTex` (как сейчас)
    * Pass B: stencil pass на target depth/stencil:

      * рисуем path mesh в stencil (по `pathId`, с mvp)
    * Pass C: composite `contentTex` → target с stencilTestDepthStencilState (как уже сделано для stencil composite)
* `drawShape`:

  * убрать `shapeCache.texture(...)`
  * рисовать **path mesh** прямо в matteTex (цвет можно белый, альфу = opacity).

7. `TVECore/Sources/TVECore/MetalRenderer/MetalRenderer.swift`

* Убрать `maskCache/shapeCache` из runtime-пути (можно оставить свойства, но не использовать).
* Добавить `PathGPUCache`:

  * создает `MTLBuffer` для `positions/indices` один раз на `pathId`.

### DoD

* В кадре нет вызовов `MaskRasterizer.rasterize`.
* anim-1/2/4 визуально не ломаются (по тестам).
* anim-3 matte mask **меняет форму** в зависимости от frame.

---

## PR-D — Тесты, которые реально ловят “animated matte mask работает”

**Цель:** тест не “есть matte команды”, а “на разных кадрах результат разный”.

### Добавить 2 теста

1. **IR-уровень** (быстрый, без Metal):

* `AnimatedPathSamplingTests` (из PR-B): AABB на 60/90 различается.

2. **Metal-интеграция** (самое важное):
   Файл: можно новый `MetalRendererAnimatedMatteMaskTests.swift`

* Компилим `example_4blocks/anim-3.json`.
* Текстуры для нужных assetId: положить простую белую/градиентную `MTLTexture` в `MockTextureProvider`.
* Рендерим offscreen кадр 60 и 90.
* Проверяем пиксель в точке, которая **должна открыться** из-за расширения маски:

  * например, справа по X: на frame 60 alpha ~0, на frame 90 alpha >> 0.

---

# 4) Что программисту делать прямо сейчас (минимальный порядок)

1. PR-A (decode) — без этого дальше всё “мнимое”.
2. PR-B (AnimPath + validator rules) — чтобы IR реально понимал path keyframes.
3. PR-C (GPU path renderer + refactor RenderCommand на pathId) — релизная архитектура, без CPU.
4. PR-D (тесты “форма меняется” + “пиксель меняется”).

---

Если хочешь, я следующим сообщением сделаю **чек-лист для ревью каждого PR** (что именно смотреть в диффе, какие edge-cases обязаны быть закрыты), но сам “план без вопросов” уже выше — он привязан к конкретным файлам и текущим местам, где у вас сейчас ломается animated matte mask.
