import Foundation

/// Render graph command - bytecode for the rendering pipeline
/// Commands are generated by AnimIR and executed by MetalRenderer
public enum RenderCommand: Sendable, Equatable {
    // MARK: - Grouping

    /// Begin a named group (for debugging and hierarchy)
    case beginGroup(name: String)

    /// End the current group
    case endGroup

    // MARK: - Transform Stack

    /// Push a transform matrix onto the stack
    case pushTransform(Matrix2D)

    /// Pop the top transform from the stack
    case popTransform

    // MARK: - Clipping

    /// Push a clip rectangle onto the stack
    case pushClipRect(RectD)

    /// Pop the top clip rectangle from the stack
    case popClipRect

    // MARK: - Drawing

    /// Draw an image asset
    case drawImage(assetId: String, opacity: Double)

    // MARK: - Masking

    /// Begin an additive mask with the given path
    case beginMaskAdd(path: BezierPath)

    /// End the current mask
    case endMask

    // MARK: - Track Matte

    /// Begin alpha track matte using the specified source layer
    case beginMatteAlpha(sourceLayerId: LayerID)

    /// Begin inverted alpha track matte using the specified source layer
    case beginMatteAlphaInverted(sourceLayerId: LayerID)

    /// End the current track matte
    case endMatte
}

// MARK: - Command Validation

extension RenderCommand {
    /// Returns true if this is a "begin" command that requires a matching "end"
    public var isBeginCommand: Bool {
        switch self {
        case .beginGroup, .pushTransform, .pushClipRect, .beginMaskAdd, .beginMatteAlpha, .beginMatteAlphaInverted:
            return true
        default:
            return false
        }
    }

    /// Returns true if this is an "end" command
    public var isEndCommand: Bool {
        switch self {
        case .endGroup, .popTransform, .popClipRect, .endMask, .endMatte:
            return true
        default:
            return false
        }
    }

    /// Returns the matching end command type for begin commands
    public var matchingEndCommand: RenderCommand? {
        switch self {
        case .beginGroup:
            return .endGroup
        case .pushTransform:
            return .popTransform
        case .pushClipRect:
            return .popClipRect
        case .beginMaskAdd:
            return .endMask
        case .beginMatteAlpha, .beginMatteAlphaInverted:
            return .endMatte
        default:
            return nil
        }
    }
}

// MARK: - Debug Description

extension RenderCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        switch self {
        case .beginGroup(let name):
            return "BeginGroup(\(name))"
        case .endGroup:
            return "EndGroup"
        case .pushTransform(let matrix):
            if matrix == .identity {
                return "PushTransform(identity)"
            }
            return "PushTransform(a:\(matrix.a), d:\(matrix.d), tx:\(matrix.tx), ty:\(matrix.ty))"
        case .popTransform:
            return "PopTransform"
        case .pushClipRect(let rect):
            return "PushClipRect(\(rect.x), \(rect.y), \(rect.width), \(rect.height))"
        case .popClipRect:
            return "PopClipRect"
        case .drawImage(let assetId, let opacity):
            return "DrawImage(\(assetId), opacity:\(opacity))"
        case .beginMaskAdd(let path):
            return "BeginMaskAdd(vertices:\(path.vertexCount), closed:\(path.closed))"
        case .endMask:
            return "EndMask"
        case .beginMatteAlpha(let sourceLayerId):
            return "BeginMatteAlpha(source:\(sourceLayerId))"
        case .beginMatteAlphaInverted(let sourceLayerId):
            return "BeginMatteAlphaInverted(source:\(sourceLayerId))"
        case .endMatte:
            return "EndMatte"
        }
    }
}

// MARK: - Command List Validation

extension Array where Element == RenderCommand {
    /// Validates that all begin/end commands are properly balanced
    /// Returns true if the command list is valid
    public func isBalanced() -> Bool { // swiftlint:disable:this cyclomatic_complexity
        var groupStack = 0
        var transformStack = 0
        var clipStack = 0
        var maskStack = 0
        var matteStack = 0

        for command in self {
            switch command {
            case .beginGroup:
                groupStack += 1
            case .endGroup:
                groupStack -= 1
                if groupStack < 0 { return false }

            case .pushTransform:
                transformStack += 1
            case .popTransform:
                transformStack -= 1
                if transformStack < 0 { return false }

            case .pushClipRect:
                clipStack += 1
            case .popClipRect:
                clipStack -= 1
                if clipStack < 0 { return false }

            case .beginMaskAdd:
                maskStack += 1
            case .endMask:
                maskStack -= 1
                if maskStack < 0 { return false }

            case .beginMatteAlpha, .beginMatteAlphaInverted:
                matteStack += 1
            case .endMatte:
                matteStack -= 1
                if matteStack < 0 { return false }

            case .drawImage:
                break
            }
        }

        return groupStack == 0 && transformStack == 0 && clipStack == 0 && maskStack == 0 && matteStack == 0
    }

    /// Returns counts of each command type for debugging
    public func commandCounts() -> [String: Int] { // swiftlint:disable:this cyclomatic_complexity
        var counts: [String: Int] = [:]

        for command in self {
            let key: String
            switch command {
            case .beginGroup: key = "beginGroup"
            case .endGroup: key = "endGroup"
            case .pushTransform: key = "pushTransform"
            case .popTransform: key = "popTransform"
            case .pushClipRect: key = "pushClipRect"
            case .popClipRect: key = "popClipRect"
            case .drawImage: key = "drawImage"
            case .beginMaskAdd: key = "beginMaskAdd"
            case .endMask: key = "endMask"
            case .beginMatteAlpha: key = "beginMatteAlpha"
            case .beginMatteAlphaInverted: key = "beginMatteAlphaInverted"
            case .endMatte: key = "endMatte"
            }
            counts[key, default: 0] += 1
        }

        return counts
    }

    /// Checks if the command list contains mask commands
    public var hasMaskCommands: Bool {
        contains { cmd in
            if case .beginMaskAdd = cmd { return true }
            return false
        }
    }

    /// Checks if the command list contains matte commands
    public var hasMatteCommands: Bool {
        contains { cmd in
            switch cmd {
            case .beginMatteAlpha, .beginMatteAlphaInverted:
                return true
            default:
                return false
            }
        }
    }
}
