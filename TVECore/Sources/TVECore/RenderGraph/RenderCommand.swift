import Foundation

// MARK: - Render Matte Mode (Renderer Level)

/// Track matte blending mode for renderer-level execution.
/// Supports all Lottie tt values including luma modes for future extensibility.
/// Separate from AnimIRTypes.MatteMode which only has alpha/alphaInverted.
public enum RenderMatteMode: Sendable, Equatable {
    /// Alpha matte - uses matte source alpha channel (tt=1)
    case alpha
    /// Inverted alpha matte - uses inverted matte source alpha (tt=2)
    case alphaInverted
    /// Luma matte - uses luminance of matte source RGB (tt=3)
    case luma
    /// Inverted luma matte - uses inverted luminance (tt=4)
    case lumaInverted
}

/// Render graph command - bytecode for the rendering pipeline
/// Commands are generated by AnimIR and executed by MetalRenderer
public enum RenderCommand: Sendable, Equatable {
    // MARK: - Grouping

    /// Begin a named group (for debugging and hierarchy)
    case beginGroup(name: String)

    /// End the current group
    case endGroup

    // MARK: - Transform Stack

    /// Push a transform matrix onto the stack
    case pushTransform(Matrix2D)

    /// Pop the top transform from the stack
    case popTransform

    // MARK: - Clipping

    /// Push a clip rectangle onto the stack
    case pushClipRect(RectD)

    /// Pop the top clip rectangle from the stack
    case popClipRect

    // MARK: - Drawing

    /// Draw an image asset
    case drawImage(assetId: String, opacity: Double)

    /// Draw a shape using GPU path rendering
    /// Used for shape layers as matte sources
    /// - Parameters:
    ///   - pathId: Reference to PathResource in PathRegistry
    ///   - fillColor: RGB fill color (0-1 each component)
    ///   - fillOpacity: Fill opacity (0-100)
    ///   - layerOpacity: Layer opacity (0-1)
    ///   - frame: Current frame for animated path interpolation
    case drawShape(pathId: PathID, fillColor: [Double]?, fillOpacity: Double, layerOpacity: Double, frame: Double)

    /// Draw a stroke around a shape path (PR-10)
    /// Renders the path outline with specified stroke style
    /// - Parameters:
    ///   - pathId: Reference to PathResource in PathRegistry
    ///   - strokeColor: RGB stroke color (0-1 each component)
    ///   - strokeOpacity: Stroke opacity (0-1)
    ///   - strokeWidth: Stroke width in pixels
    ///   - lineCap: Line cap style (1=butt, 2=round, 3=square)
    ///   - lineJoin: Line join style (1=miter, 2=round, 3=bevel)
    ///   - miterLimit: Miter limit for miter joins
    ///   - layerOpacity: Layer opacity (0-1)
    ///   - frame: Current frame for animated path interpolation
    case drawStroke(
        pathId: PathID,
        strokeColor: [Double],
        strokeOpacity: Double,
        strokeWidth: Double,
        lineCap: Int,
        lineJoin: Int,
        miterLimit: Double,
        layerOpacity: Double,
        frame: Double
    )

    // MARK: - Masking

    /// Begin a mask scope with boolean operation mode for GPU mask accumulation.
    /// Masks are applied via coverage texture and combined using the specified mode.
    /// - Parameters:
    ///   - mode: Boolean operation (add/subtract/intersect)
    ///   - inverted: Whether to invert coverage before applying operation
    ///   - pathId: Reference to PathResource in PathRegistry
    ///   - opacity: Mask opacity (0.0 to 1.0)
    ///   - frame: Current frame for animated path interpolation
    case beginMask(mode: MaskMode, inverted: Bool, pathId: PathID, opacity: Double, frame: Double)

    /// End the current mask
    case endMask

    // MARK: - Track Matte

    /// Begin track matte scope with the specified mode.
    /// The scope must contain exactly two child groups in order:
    /// 1. `beginGroup("matteSource")` - commands rendering the matte source
    /// 2. `beginGroup("matteConsumer")` - commands rendering the consumer layer
    case beginMatte(mode: RenderMatteMode)

    /// End the current track matte scope
    case endMatte
}

// MARK: - Command Validation

extension RenderCommand {
    /// Returns true if this is a "begin" command that requires a matching "end"
    public var isBeginCommand: Bool {
        switch self {
        case .beginGroup, .pushTransform, .pushClipRect, .beginMask, .beginMatte:
            return true
        default:
            return false
        }
    }

    /// Returns true if this is an "end" command
    public var isEndCommand: Bool {
        switch self {
        case .endGroup, .popTransform, .popClipRect, .endMask, .endMatte:
            return true
        default:
            return false
        }
    }

    /// Returns the matching end command type for begin commands
    public var matchingEndCommand: RenderCommand? {
        switch self {
        case .beginGroup:
            return .endGroup
        case .pushTransform:
            return .popTransform
        case .pushClipRect:
            return .popClipRect
        case .beginMask:
            return .endMask
        case .beginMatte:
            return .endMatte
        default:
            return nil
        }
    }
}

// MARK: - Debug Description

extension RenderCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        switch self {
        case .beginGroup(let name):
            return "BeginGroup(\(name))"
        case .endGroup:
            return "EndGroup"
        case .pushTransform(let matrix):
            if matrix == .identity {
                return "PushTransform(identity)"
            }
            return "PushTransform(a:\(matrix.a), d:\(matrix.d), tx:\(matrix.tx), ty:\(matrix.ty))"
        case .popTransform:
            return "PopTransform"
        case .pushClipRect(let rect):
            return "PushClipRect(\(rect.x), \(rect.y), \(rect.width), \(rect.height))"
        case .popClipRect:
            return "PopClipRect"
        case .drawImage(let assetId, let opacity):
            return "DrawImage(\(assetId), opacity:\(opacity))"
        case .drawShape(let pathId, _, let fillOpacity, let layerOpacity, let frame):
            return "DrawShape(pathId:\(pathId.value), fillOp:\(fillOpacity), layerOp:\(layerOpacity), frame:\(frame))"
        case .drawStroke(let pathId, _, let strokeOpacity, let strokeWidth, let lineCap, let lineJoin, _, let layerOpacity, let frame):
            return "DrawStroke(pathId:\(pathId.value), w:\(strokeWidth), lc:\(lineCap), lj:\(lineJoin), sOp:\(strokeOpacity), lOp:\(layerOpacity), frame:\(frame))"
        case .beginMask(let mode, let inverted, let pathId, let opacity, let frame):
            return "BeginMask(mode:\(mode.rawValue), inv:\(inverted), pathId:\(pathId.value), op:\(opacity), frame:\(frame))"
        case .endMask:
            return "EndMask"
        case .beginMatte(let mode):
            return "BeginMatte(\(mode))"
        case .endMatte:
            return "EndMatte"
        }
    }
}

// MARK: - Command List Validation

extension Array where Element == RenderCommand {
    /// Validates that all begin/end commands are properly balanced
    /// Returns true if the command list is valid
    public func isBalanced() -> Bool {
        var stacks = BalanceStacks()
        for command in self {
            guard stacks.process(command) else { return false }
        }
        return stacks.allZero
    }
}

/// Helper for tracking command balance
private struct BalanceStacks {
    var group = 0
    var transform = 0
    var clip = 0
    var mask = 0
    var matte = 0

    var allZero: Bool {
        group == 0 && transform == 0 && clip == 0 && mask == 0 && matte == 0
    }

    mutating func increment(_ command: RenderCommand) {
        switch command {
        case .beginGroup: group += 1
        case .pushTransform: transform += 1
        case .pushClipRect: clip += 1
        case .beginMask: mask += 1
        case .beginMatte: matte += 1
        default: break
        }
    }

    mutating func decrement(_ command: RenderCommand) -> Bool {
        switch command {
        case .endGroup: group -= 1; return group >= 0
        case .popTransform: transform -= 1; return transform >= 0
        case .popClipRect: clip -= 1; return clip >= 0
        case .endMask: mask -= 1; return mask >= 0
        case .endMatte: matte -= 1; return matte >= 0
        default: return true
        }
    }

    mutating func process(_ command: RenderCommand) -> Bool {
        increment(command)
        return decrement(command)
    }
}

extension Array where Element == RenderCommand {
    // Returns counts of each command type for debugging
    // swiftlint:disable:next cyclomatic_complexity
    public func commandCounts() -> [String: Int] {
        var counts: [String: Int] = [:]

        for command in self {
            let key: String
            switch command {
            case .beginGroup: key = "beginGroup"
            case .endGroup: key = "endGroup"
            case .pushTransform: key = "pushTransform"
            case .popTransform: key = "popTransform"
            case .pushClipRect: key = "pushClipRect"
            case .popClipRect: key = "popClipRect"
            case .drawImage: key = "drawImage"
            case .drawShape: key = "drawShape"
            case .drawStroke: key = "drawStroke"
            case .beginMask: key = "beginMask"
            case .endMask: key = "endMask"
            case .beginMatte: key = "beginMatte"
            case .endMatte: key = "endMatte"
            }
            counts[key, default: 0] += 1
        }

        return counts
    }

    /// Checks if the command list contains mask commands
    public var hasMaskCommands: Bool {
        contains { cmd in
            switch cmd {
            case .beginMask: return true
            default: return false
            }
        }
    }

    /// Checks if the command list contains matte commands
    public var hasMatteCommands: Bool {
        contains { cmd in
            if case .beginMatte = cmd { return true }
            return false
        }
    }
}
