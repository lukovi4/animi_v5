import Foundation

/// Render graph command - bytecode for the rendering pipeline
/// Commands are generated by AnimIR and executed by MetalRenderer
public enum RenderCommand: Sendable, Equatable {
    // MARK: - Grouping

    /// Begin a named group (for debugging and hierarchy)
    case beginGroup(name: String)

    /// End the current group
    case endGroup

    // MARK: - Transform Stack

    /// Push a transform matrix onto the stack
    case pushTransform(Matrix2D)

    /// Pop the top transform from the stack
    case popTransform

    // MARK: - Clipping

    /// Push a clip rectangle onto the stack
    case pushClipRect(RectD)

    /// Pop the top clip rectangle from the stack
    case popClipRect

    // MARK: - Drawing

    /// Draw an image asset
    case drawImage(assetId: String, opacity: Double)

    // MARK: - Masking

    /// Begin an additive mask with the given path
    case beginMaskAdd(path: BezierPath)

    /// End the current mask
    case endMask

    // MARK: - Track Matte

    /// Begin alpha track matte using the specified source layer
    case beginMatteAlpha(sourceLayerId: LayerID)

    /// Begin inverted alpha track matte using the specified source layer
    case beginMatteAlphaInverted(sourceLayerId: LayerID)

    /// End the current track matte
    case endMatte
}

// MARK: - Command Validation

extension RenderCommand {
    /// Returns true if this is a "begin" command that requires a matching "end"
    public var isBeginCommand: Bool {
        switch self {
        case .beginGroup, .pushTransform, .pushClipRect, .beginMaskAdd, .beginMatteAlpha, .beginMatteAlphaInverted:
            return true
        default:
            return false
        }
    }

    /// Returns true if this is an "end" command
    public var isEndCommand: Bool {
        switch self {
        case .endGroup, .popTransform, .popClipRect, .endMask, .endMatte:
            return true
        default:
            return false
        }
    }

    /// Returns the matching end command type for begin commands
    public var matchingEndCommand: RenderCommand? {
        switch self {
        case .beginGroup:
            return .endGroup
        case .pushTransform:
            return .popTransform
        case .pushClipRect:
            return .popClipRect
        case .beginMaskAdd:
            return .endMask
        case .beginMatteAlpha, .beginMatteAlphaInverted:
            return .endMatte
        default:
            return nil
        }
    }
}

// MARK: - Debug Description

extension RenderCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        switch self {
        case .beginGroup(let name):
            return "BeginGroup(\(name))"
        case .endGroup:
            return "EndGroup"
        case .pushTransform(let matrix):
            if matrix == .identity {
                return "PushTransform(identity)"
            }
            return "PushTransform(a:\(matrix.a), d:\(matrix.d), tx:\(matrix.tx), ty:\(matrix.ty))"
        case .popTransform:
            return "PopTransform"
        case .pushClipRect(let rect):
            return "PushClipRect(\(rect.x), \(rect.y), \(rect.width), \(rect.height))"
        case .popClipRect:
            return "PopClipRect"
        case .drawImage(let assetId, let opacity):
            return "DrawImage(\(assetId), opacity:\(opacity))"
        case .beginMaskAdd(let path):
            return "BeginMaskAdd(vertices:\(path.vertexCount), closed:\(path.closed))"
        case .endMask:
            return "EndMask"
        case .beginMatteAlpha(let sourceLayerId):
            return "BeginMatteAlpha(source:\(sourceLayerId))"
        case .beginMatteAlphaInverted(let sourceLayerId):
            return "BeginMatteAlphaInverted(source:\(sourceLayerId))"
        case .endMatte:
            return "EndMatte"
        }
    }
}

// MARK: - Command List Validation

extension Array where Element == RenderCommand {
    /// Validates that all begin/end commands are properly balanced
    /// Returns true if the command list is valid
    public func isBalanced() -> Bool {
        var stacks = BalanceStacks()
        for command in self {
            guard stacks.process(command) else { return false }
        }
        return stacks.allZero
    }
}

/// Helper for tracking command balance
private struct BalanceStacks {
    var group = 0
    var transform = 0
    var clip = 0
    var mask = 0
    var matte = 0

    var allZero: Bool {
        group == 0 && transform == 0 && clip == 0 && mask == 0 && matte == 0
    }

    mutating func increment(_ command: RenderCommand) {
        switch command {
        case .beginGroup: group += 1
        case .pushTransform: transform += 1
        case .pushClipRect: clip += 1
        case .beginMaskAdd: mask += 1
        case .beginMatteAlpha, .beginMatteAlphaInverted: matte += 1
        default: break
        }
    }

    mutating func decrement(_ command: RenderCommand) -> Bool {
        switch command {
        case .endGroup: group -= 1; return group >= 0
        case .popTransform: transform -= 1; return transform >= 0
        case .popClipRect: clip -= 1; return clip >= 0
        case .endMask: mask -= 1; return mask >= 0
        case .endMatte: matte -= 1; return matte >= 0
        default: return true
        }
    }

    mutating func process(_ command: RenderCommand) -> Bool {
        increment(command)
        return decrement(command)
    }
}

extension Array where Element == RenderCommand {
    /// Returns counts of each command type for debugging
    public func commandCounts() -> [String: Int] {
        var counts: [String: Int] = [:]

        for command in self {
            let key: String
            switch command {
            case .beginGroup: key = "beginGroup"
            case .endGroup: key = "endGroup"
            case .pushTransform: key = "pushTransform"
            case .popTransform: key = "popTransform"
            case .pushClipRect: key = "pushClipRect"
            case .popClipRect: key = "popClipRect"
            case .drawImage: key = "drawImage"
            case .beginMaskAdd: key = "beginMaskAdd"
            case .endMask: key = "endMask"
            case .beginMatteAlpha: key = "beginMatteAlpha"
            case .beginMatteAlphaInverted: key = "beginMatteAlphaInverted"
            case .endMatte: key = "endMatte"
            }
            counts[key, default: 0] += 1
        }

        return counts
    }

    /// Checks if the command list contains mask commands
    public var hasMaskCommands: Bool {
        contains { cmd in
            if case .beginMaskAdd = cmd { return true }
            return false
        }
    }

    /// Checks if the command list contains matte commands
    public var hasMatteCommands: Bool {
        contains { cmd in
            switch cmd {
            case .beginMatteAlpha, .beginMatteAlphaInverted:
                return true
            default:
                return false
            }
        }
    }
}
