import Foundation

// MARK: - Render Matte Mode (Renderer Level)

/// Track matte blending mode for renderer-level execution.
/// Supports all Lottie tt values including luma modes for future extensibility.
/// Separate from AnimIRTypes.MatteMode which only has alpha/alphaInverted.
public enum RenderMatteMode: Sendable, Equatable {
    /// Alpha matte - uses matte source alpha channel (tt=1)
    case alpha
    /// Inverted alpha matte - uses inverted matte source alpha (tt=2)
    case alphaInverted
    /// Luma matte - uses luminance of matte source RGB (tt=3)
    case luma
    /// Inverted luma matte - uses inverted luminance (tt=4)
    case lumaInverted
}

/// Render graph command - bytecode for the rendering pipeline
/// Commands are generated by AnimIR and executed by MetalRenderer
public enum RenderCommand: Sendable, Equatable {
    // MARK: - Grouping

    /// Begin a named group (for debugging and hierarchy)
    case beginGroup(name: String)

    /// End the current group
    case endGroup

    // MARK: - Transform Stack

    /// Push a transform matrix onto the stack
    case pushTransform(Matrix2D)

    /// Pop the top transform from the stack
    case popTransform

    // MARK: - Clipping

    /// Push a clip rectangle onto the stack
    case pushClipRect(RectD)

    /// Pop the top clip rectangle from the stack
    case popClipRect

    // MARK: - Drawing

    /// Draw an image asset
    case drawImage(assetId: String, opacity: Double)

    /// Draw a shape (rasterized from BezierPath)
    /// Used for shape layers as matte sources
    case drawShape(path: BezierPath, fillColor: [Double]?, fillOpacity: Double, layerOpacity: Double)

    // MARK: - Masking

    /// Begin an additive mask with the given path and opacity
    /// - Parameters:
    ///   - path: Bezier path defining the mask shape
    ///   - opacity: Mask opacity (0.0 to 1.0)
    case beginMaskAdd(path: BezierPath, opacity: Double)

    /// End the current mask
    case endMask

    // MARK: - Track Matte

    /// Begin track matte scope with the specified mode.
    /// The scope must contain exactly two child groups in order:
    /// 1. `beginGroup("matteSource")` - commands rendering the matte source
    /// 2. `beginGroup("matteConsumer")` - commands rendering the consumer layer
    case beginMatte(mode: RenderMatteMode)

    /// End the current track matte scope
    case endMatte
}

// MARK: - Command Validation

extension RenderCommand {
    /// Returns true if this is a "begin" command that requires a matching "end"
    public var isBeginCommand: Bool {
        switch self {
        case .beginGroup, .pushTransform, .pushClipRect, .beginMaskAdd, .beginMatte:
            return true
        default:
            return false
        }
    }

    /// Returns true if this is an "end" command
    public var isEndCommand: Bool {
        switch self {
        case .endGroup, .popTransform, .popClipRect, .endMask, .endMatte:
            return true
        default:
            return false
        }
    }

    /// Returns the matching end command type for begin commands
    public var matchingEndCommand: RenderCommand? {
        switch self {
        case .beginGroup:
            return .endGroup
        case .pushTransform:
            return .popTransform
        case .pushClipRect:
            return .popClipRect
        case .beginMaskAdd:
            return .endMask
        case .beginMatte:
            return .endMatte
        default:
            return nil
        }
    }
}

// MARK: - Debug Description

extension RenderCommand: CustomDebugStringConvertible {
    public var debugDescription: String {
        switch self {
        case .beginGroup(let name):
            return "BeginGroup(\(name))"
        case .endGroup:
            return "EndGroup"
        case .pushTransform(let matrix):
            if matrix == .identity {
                return "PushTransform(identity)"
            }
            return "PushTransform(a:\(matrix.a), d:\(matrix.d), tx:\(matrix.tx), ty:\(matrix.ty))"
        case .popTransform:
            return "PopTransform"
        case .pushClipRect(let rect):
            return "PushClipRect(\(rect.x), \(rect.y), \(rect.width), \(rect.height))"
        case .popClipRect:
            return "PopClipRect"
        case .drawImage(let assetId, let opacity):
            return "DrawImage(\(assetId), opacity:\(opacity))"
        case .drawShape(let path, _, let fillOpacity, let layerOpacity):
            return "DrawShape(vertices:\(path.vertexCount), fillOp:\(fillOpacity), layerOp:\(layerOpacity))"
        case .beginMaskAdd(let path, let opacity):
            return "BeginMaskAdd(vertices:\(path.vertexCount), closed:\(path.closed), opacity:\(opacity))"
        case .endMask:
            return "EndMask"
        case .beginMatte(let mode):
            return "BeginMatte(\(mode))"
        case .endMatte:
            return "EndMatte"
        }
    }
}

// MARK: - Command List Validation

extension Array where Element == RenderCommand {
    /// Validates that all begin/end commands are properly balanced
    /// Returns true if the command list is valid
    public func isBalanced() -> Bool {
        var stacks = BalanceStacks()
        for command in self {
            guard stacks.process(command) else { return false }
        }
        return stacks.allZero
    }
}

/// Helper for tracking command balance
private struct BalanceStacks {
    var group = 0
    var transform = 0
    var clip = 0
    var mask = 0
    var matte = 0

    var allZero: Bool {
        group == 0 && transform == 0 && clip == 0 && mask == 0 && matte == 0
    }

    mutating func increment(_ command: RenderCommand) {
        switch command {
        case .beginGroup: group += 1
        case .pushTransform: transform += 1
        case .pushClipRect: clip += 1
        case .beginMaskAdd: mask += 1
        case .beginMatte: matte += 1
        default: break
        }
    }

    mutating func decrement(_ command: RenderCommand) -> Bool {
        switch command {
        case .endGroup: group -= 1; return group >= 0
        case .popTransform: transform -= 1; return transform >= 0
        case .popClipRect: clip -= 1; return clip >= 0
        case .endMask: mask -= 1; return mask >= 0
        case .endMatte: matte -= 1; return matte >= 0
        default: return true
        }
    }

    mutating func process(_ command: RenderCommand) -> Bool {
        increment(command)
        return decrement(command)
    }
}

extension Array where Element == RenderCommand {
    // Returns counts of each command type for debugging
    // swiftlint:disable:next cyclomatic_complexity
    public func commandCounts() -> [String: Int] {
        var counts: [String: Int] = [:]

        for command in self {
            let key: String
            switch command {
            case .beginGroup: key = "beginGroup"
            case .endGroup: key = "endGroup"
            case .pushTransform: key = "pushTransform"
            case .popTransform: key = "popTransform"
            case .pushClipRect: key = "pushClipRect"
            case .popClipRect: key = "popClipRect"
            case .drawImage: key = "drawImage"
            case .drawShape: key = "drawShape"
            case .beginMaskAdd: key = "beginMaskAdd"
            case .endMask: key = "endMask"
            case .beginMatte: key = "beginMatte"
            case .endMatte: key = "endMatte"
            }
            counts[key, default: 0] += 1
        }

        return counts
    }

    /// Checks if the command list contains mask commands
    public var hasMaskCommands: Bool {
        contains { cmd in
            if case .beginMaskAdd = cmd { return true }
            return false
        }
    }

    /// Checks if the command list contains matte commands
    public var hasMatteCommands: Bool {
        contains { cmd in
            if case .beginMatte = cmd { return true }
            return false
        }
    }
}
