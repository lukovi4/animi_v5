Отлично: по твоим тестам **morph реально работает на уровне MetalRenderer** (и данные keyframes корректны). Значит проблема **не в path sampling**, а в том, **как сцена проигрывается в приложении**: либо рисуется **не тот блок/не тот variant**, либо **время/кадр “залипает”**, либо **registry/команды не соответствуют текущему кадру**, либо **не попадаем в matte-pass для сцены**.

Раз морф виден в `drawOffscreen(anim-3)` тесте, а в приложении “не виден”, вот 4 наиболее вероятные причины (в порядке вероятности) + точные проверки.

---

## 1) В приложении вы, скорее всего, НЕ играете `anim-3`

В сцене 4 блока (anim-1..4). В UI можно смотреть на блок, где mattes нет, и думать что “anim-3 не морфится”.

✅ Проверка без гаданий (5 минут):
В `PlayerViewController` (там где получаете `commands`):

* посчитай, есть ли в текущем кадре **хотя бы один matte scope**:

  * `commands.contains(.beginMatte…)` / `commands.hasMatteCommands`
* и отдельно: есть ли `drawShape(pathId:..., frame:...)` (это matte-source shape).

Если **matte команд нет**, значит:

* либо сейчас рисуется другой anim (не anim-3),
* либо выбрана не та variant/не тот mediaBlock,
* либо в сцене отключён этот блок (тайминг/zIndex/visibility).

➡️ Тогда фикс не в рендерере, а в выборе блока/варианта.

---

## 2) FrameIndex в приложении не меняется так, как ты думаешь (scrub/loop/time policy)

Твой тест показывает morph между **75 и 90** (это правильный диапазон).
Если в приложении по факту кадр “всегда 60” или “перескакивает 60→90 быстро”, морф визуально можно не заметить.

✅ Проверка:
В `PlayerViewController` раз в 0.5 сек лог:

* `sceneFrameIndex`
* и (важно) **какой frame попал в команды**:

  * например, из первого `drawShape` достать `frame` и вывести.

Ожидается:

* frame растёт: …72,73,74,75…90…
  Если видишь “всегда 60” или “0..1” — проблема во времени.

---

## 3) В runtime `pathRegistry` корректный, но **не тот** для текущих `commands` (копия runtime/перекомпиляция)

Ты уже чинил “пустой registry”. Но может быть **рассинхрон**:

* `commands` собраны из одного `SceneRuntime`,
* а `pathRegistry` взят из другого (старого `player.mergedPathRegistry`).

Это особенно легко, если compile делается повторно (смена media/variant), а `mergedPathRegistry` не обновляется синхронно, или UI держит старую ссылку.

✅ Проверка (железная):

* В `ScenePlayer.compile()` добавить `sceneRuntimeId = UUID()` и сохранить в runtime.
* В `PlayerViewController` перед рендером логнуть:

  * `runtimeId`
  * `pathRegistry.count`
* И в `renderCommands(sceneFrameIndex:)` тоже логнуть `runtimeId`.

Если runtimeId в commands ≠ runtimeId у registry — это 100% причина.

**Фикс:** registry должен храниться внутри `SceneRuntime` и передаваться вместе с ним (а не отдельным полем в player, которое может устареть).

---

## 4) Matte-pass в сцене есть, но “мorph не виден” из-за композиции/координат (масштаб/transform root)

Ты пишешь:

> “координаты/масштаб при рендеринге сцены отличаются от тестов”

Это реально возможно: если матт рисуется, но:

* рисуется в другом месте (transform/rootParentTransform),
* и поэтому клип не меняется в зоне, где ты смотришь,
* или клип меняется, но совпадает с bounds слоя и выглядит как opacity.

✅ Проверка:
Сделайте **debug overlay** (на 1 вечер, но очень полезно):

* в `renderMatteScope` временно включить режим:

  * рендерить `matteTex` прямо на экран в угол (picture-in-picture)
  * или просто отрисовать matte source shape белым поверх сцены с 30% alpha
    Тогда ты сразу увидишь: форма реально расширяется или нет, и где она находится.

---

# Что я прошу сделать (минимум кода, максимум сигнала)

### A) Один лог в PlayerViewController на каждый N-й кадр

Вывести:

* `sceneFrameIndex`
* `commands.hasMatteCommands` (true/false)
* `firstDrawShapeFrame` (из `drawShape(... frame:)` если есть)
* `pathRegistry.count`

### B) Убедиться, что на экране именно блок anim-3

Самый простой тест: временно скрыть остальные блоки (zIndex/alpha) или отрисовать только один mediaBlock.

### C) Если matte команды есть и frame идёт 75→90, но всё равно не видно — включить debug визуализацию matteTex

Это даст окончательный ответ за 5 минут.

---

## Мой вывод по твоему отчёту

Рендерер и интерполяция — **исправны**.
Проблема в приложении — **что-то в связке “какой кадр/какой блок/какой runtime/какие команды”**.

Скинь 20–30 строк из `PlayerViewController`, где вычисляется `sceneFrameIndex` и вызывается `player.renderCommands(sceneFrameIndex:)`, и структуру `renderCommands` в `ScenePlayer` (как выбирается block/variant). Я скажу точную точку, где “теряется” anim-3 или кадр.
